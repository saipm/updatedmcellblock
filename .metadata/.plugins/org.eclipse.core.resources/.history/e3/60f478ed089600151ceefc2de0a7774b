

    by: Antonin Januska Date: 21.08.2014 Categories: Front End 

Last Saturday, I gave yet another talk on getting started with AngularJS and with good success. I found myself wondering though, along the way, why is it that we keep needing these “getting started” talks with Angular? What makes it so complicated? Why do we need endless “basic” tutorials?

I think the answer lies in the fact that AngularJS docs do not prepare you for Angular and good getting started tutorials don’t exist in the top 10 of google’s results. On top of that, finding one of your developer friends being an expert in Angular is impossible. In the grand scheme of things, it’s a small framework. Especially compared to the behemoth that jQuery is.

On top of that, we’re in the age of Udemy and similar services where you pay for a class as a way to thank an expert for sharing their knowledge. All of this makes Angular on-boarding difficult.

So I would like to rewrite my talk for you as a tutorial. You can view the presentation itself here and the code examples for the presentation on my github.

So before we get to “how to use Angular”, let’s discuss “why” and “what” Angular is.
About AngularJS

AngularJS is an MV*-style javascript framework. You may already be familiar with MVC architecture: model/view/controller. In Angular’s case (and many other frameworks’), the “controller” part is a little muddy. Unlike traditional back-end frameworks, the controller isn’t the middle man between the request and response but rather, it’s a scoped object that may contain functions, additional logic, and helps every part of the application interact together.

Now, despite AngularJS coming into the mainstream just about two years ago, its initial release was actually back in 2009. Its development really took off when one of the original creators started working at Google and over time, Google put its weight behind it, making it enterprise-ready over time.

What do I mean by that? Well, if you’ve ever spent any amount of time in the development world, you’ll know that long-term enterprise-y projects are 10% solution, 10% optimization, and 80% legibility under which I also classify architecture, maintenance and similar concepts. AngularJS does a good job separating different portions of an application into various files where a view, for instance, does not conflict with a controller or other libraries. Nothing is necessarily tied together except via dependency injection.

And since it’s backed by Google, we can bet that it will be around for a few years and won’t disappear into the nether (similar to what happened to KnockoutJS, unfortunately).

During my talk, I wanted to emphasize just how greatly AngularJS is enterprise-ready. It’s like Zend or Symfony for PHP or (the default) Java. Due to its architecture, new developers can jump in after learning the basics of Angular since most applications follow the semi-rigid pattern that Angular sets up.

Lastly, keep in mind that Angular is a FRONT-END framework that runs single-page apps. That means that what makes it special is that it can load and interact with data without reloading the page or having to rely on the server to figure out how to display data.
“Single Page Apps” the Old Way.

Or, “via jQuery”. Single Page Apps didn’t really exist until recently but before that happened, we TRIED and (somewhat) failed to build SAPs via jQuery. Our “apps” were more of “let me use jQuery to fetch a page and copy/paste that DOM into the current page”.

So let’s see how this was done and what problems arise along the way.
App 1

$(document).ready(function(){
    $('#some-element').click(function(e){
        //some interaction
        e.preventDefault();
    });

});

Easy, right? I think we’re all used to the typical jQuery syntax of “dom ready” and binding our listeners. That’s pretty much jQuery: an easy syntax for adding listeners and have those perform some kind of functionality. When jQuery first came out, it became the sugar on top of HTML. Meaning that you could submit a form without refreshing a page, add some neat animations, etc. But, you couldn’t do any super fancy stuff.

Everything is all fine and dandy in the world if you stick to this pattern.
App 2

Let’s look at another example that will illustrate the shortcomings of this approach.

$(document).ready(function() {
    $('#some-element').click(function(e){
        $.get('/api/list-comments', function(data) {
            var $comments = $('<div></div>');
            $comments.addClass('comment-list');

            for(comment in data.comments) {
                var $comment = $('<div></div>');
                $comment.addClass('comment');

                var $link = $('<a></a>');
                $link.attr('href', comment.userUrl);
                $link.addClass('user');
                $comment.append($link);

                var $content = $('<div></div>');
                $content.addClass('comment-content');
                $content.html(comment.content);
            }

            $('.comment-list').html('');
            $('.comment-list').append($comments);
        });
        e.preventDefault();
    });

});

If your first thought after looking at this code is “ew”, then you’re correct. It’s terrible code. It’s terrible jQuery, but unfortunately, it illustrates the reality of using a javascript library without templates to, well, do a workaround and try to template data nevertheless.

Now, given, jQuery is not meant to be used this way, there are plenty of people who have and continue to do so.

There is no way to template with jQuery, that means that we either have to use strings to concatenate strings of HTML and then have jQuery interpret it or do as I did above. While factories may help (passing information to a dedicated function that will build all this stuff for us), they end up doing the same stuff as before, just nicer.
Let’s get into the bigger problems.

As you can already tell, that code above is not only unmaintainable, it’s difficult to follow and understand. This creates a big problem. You know how I said most projects are 80% legibility? We’ve just failed that.

Here are the under-lying issues:

    listeners no longer work on new elements, the listeners have to attach on the parent-most element and wait for bubbling like so: $('body').on('click', '.comment-like', function() {});. This means, we’ll end up with a slew of listeners waiting at the top element where jQuery tries to figure out if the initial event dispatcher element matches what we need.
    any state changes and updates have to be manually tracked. Since there is no two-way binding, we’ll need to implement our own listener/dispatcher system for data. To put this in perspective, if we have a counter for “comment likes”, we’ll have to manually fire off a “counting function” whenever a comment is liked, make sure that the comment is not double-counted, etc.
    There is no way to build a multi-page app. Separate pages would have to be either stashed somewhere or “display:none”d similar to how tabs work.
    Speed. Since we have to create work-arounds and extra code, we’ll most likely experience speed issues, this is something to consider. There are benchmarks you can check out on this matter, just make sure you dig deep enough to find fair and sensible comparisons.
    jQuery isn’t difficult to maintain by itself or for the purposes it was created. There are even certain design patterns for using jQuery; however, if you’re trying to build a single-page-app with jQuery, you’re better off hammering a nail with a t-shirt.
    Again, templating. Templating, templating, templating is the biggest issue here and AngularJS is pretty much the best framework out there for dealing with that.

Enter AngularJS

So what does AngularJS bring to the table? Lots:

Routing – server-side-like routing that allows us for the application to change the URL. Historyjs-like functionality included. This means that loading up a deep-linked page won’t cause any issues and wherever you go in the site, the URL will update.

Templating – a biggie. Not only does Angular have templating but it also supports handlebars-like templating for displaying data. This is contrary to, let’s say, KnockoutJS that used data-bind as an attribute to show data.

Variable tracking / data-binding – this is the crux of MV* frameworks and AngularJS does a great job with it. It’s also automatic where you can simply add a variable to the $scope and have it tracked unlike KOjs where you have to manually declare each variable as “observable” or “computed”.

No listeners – the event listener paradigm doesn’t really exist in AngularJS. You can declare functions and then bind them to an event via ng-click for instance, but the experience is completely different from jQuery where your listener is removed from your template and declared independent of your view. At first, this seems counterintuitive but it works really well.

Separation of concerns – this is the “enterprise-y” part of AngularJS. There are services, factories, encapsulation, and dependency injection all of which allow many different developers to work on a project together, reuse code, and keep it DRY.

All of that makes a full front-end framework that requires no additional libraries on the side.

side note: Angular router was taken out of core a year ago or so, and is not available separately. This opened an avenue for libraries like ui router which serve as more featureful alternatives.
Let us App

I’d like to go over the concepts above more in-depth while I go over how to use them. It makes more sense in practice than on paper and you’ll quickly see that. I strongly believe in teaching what you’ll use and show the academic side of things on the go rather than give you a ton of boilerplate that won’t make sense.

I think of learning Angular like peeling an onion backward. You keep adding more layers to create something bigger and better but you don’t need to have all the layers ready to start!

I created a list of various “steps” to teach. You can check out the code in its github repo, and live preview online on my dokku server. Note, you’ll have to manually change the URL (
Data binding and affecting data output

Before we get into the nitty gritty of setting up a controller (which is not a true controller in my opinion), we should explore the beauty of angular from the beginning.

One of the most fantastic things about Angular is that when you create a “model”, whatever changes you make will be updated immediately. Let’s look at Step 1

Link

Go ahead and enter whatever you want in that input field. See that? Instance response. Here’s what the code looks like:

<html>
    <head>
        <title>Step 1</title>
    <link href="tseczka.css" rel="stylesheet" type="text/css">
    <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.2.19/angular.min.js"></script>
    </head>
    <body ng-app>
        <div class="row">
            <div class="col-6">
                <input type="text" ng-model="myText">
            </div>
            <div class="col-6 last">
                {{ myText }}
            </div>
        </div>
    </body>
</html>